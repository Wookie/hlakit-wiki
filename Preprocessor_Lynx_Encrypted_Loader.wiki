=Encrypted Loader=

When the Atari Lynx boots, the built-in ROM code loads and decrypts a single 256 byte frame of RSA encoded executable into memory location 0x0200 and then jumps to it.  This initial executable is called the loader.  It is possible to have a loader larger than 256 bytes long by making the first frame of loader code adjust a variable in the zero page and then jumping back to the RSA load and decrypt function in the Atari Lynx ROM.

After every frame of data is loaded and decrypted, the ROM code jumps to 0x0200.  That means you need to use self-modifying code at the beginning of the first frame to load multiple frames.  There is a more extensive description [[http://www.classicgamedev.com/Blog:Hacking_Classics/Lynx_Encryption|here]].

**#lynx.loader function**

The HLAKit Lynx Platform code supports designating a loader function that gets wrapped in some boilerplate loader code and then gets encrypted using the known Lynx RSA private key.

====Example====
{{{
#!c
#lynx.loader loader

function loader() 
{
    // loader code
}
}}}

The boilerplate loader code is a simple self-modifying bit of code that is able to load an arbitrary number of frames of encrypted data from the ROM.  This allows you to make your loader function as long and complex as you would like and the loader just works.

The trick to making the boilerplate work is to put a BRA . instruction as the first instruction in the first frame of executable so that it lands at 0x0200.  After the first frame is loaded and decrypted, the CPU will jump to 0x0200.  The first time it does this, the BRA will just branch to the next instruction.  The next instructions will decrement a frame counter and modify the destination pointer for the next frame of encrypted data to be loaded into and then jump back into the RSA load and decrypt ROM function.

By using the #lynx.loader directive, HLAKit will compile your loader function into a binary executable and measure how large it is.  It will then figure out how many frames of encrypted data are needed to store the loader and it will hard code the frame counter in the boilerplate loader code so that the entire loader function is loaded and decrypted into memory.  When the last frame of encrypted data is loaded and decrypted, the boilerplate code will jump to the loader function.

There is a caveat here.  I wouldn't do to much in your loader function other than load in your main executable and jump to it.  To do anything else like show a graphic and/or play music you will likely call library functions to do that.  Since the entire loader has to be encrypted, the library functions have to be included in the binary image that gets encrypted, thus duplicating the library function you use in the resulting binary.

My general strategy is to write a loader function that is the bare minimum needed to load in the main executable so that the encrypted loaded binary is as small and fast as possible.
