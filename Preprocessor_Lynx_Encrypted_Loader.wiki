=Encrypted Loader=

When the Atari Lynx boots, the system ROM code loads and decrypts a single 256 byte frame of RSA encoded executable into memory location 0x0200 and then jumps to it.  This initial executable is called the loader.  It is possible to have a loader larger than 256 bytes long by making the first frame of loader code adjust a few variables in the zero page and then jump back to the RSA load and decrypt function in the system ROM.

After every frame of data is loaded and decrypted, the system ROM code jumps to 0x0200.  That means you need to use self-modifying code at the beginning of the first frame to load multiple frames.  There is a more extensive description [[http://www.classicgamedev.com/Blog:Hacking_Classics/Lynx_Encryption|here]].

**#lynx.loader function**

The HLAKit Lynx Platform code supports designating a loader function that gets wrapped in some boilerplate loader code and then gets encrypted using the known Lynx RSA private key.

====Example====
{{{
#!c
#lynx.loader load_my_game

function load_my_game() 
{
    // code to load your game into RAM
}
}}}

The boilerplate loader code is a simple self-modifying bit of code that is able to load an arbitrary number of frames of encrypted data from the ROM.  This allows you to make your loader function as long and complex as you would like and the loader just works.

The trick to making the boilerplate work is to put a BRA . instruction as the first instruction in the first frame of executable so that it lands at 0x0200.  After the first frame is loaded and decrypted, the CPU will jump to 0x0200.  The first time it does this, the BRA will just branch to the next instruction.  The next instructions will decrement a frame counter and modify the destination pointer for the next frame of encrypted data to be loaded into and then jump back into the RSA load and decrypt ROM function.

By using the #lynx.loader directive, HLAKit will compile your loader function into a binary executable and measure how large it is.  It will then figure out how many frames of encrypted data are needed to store the loader and it will hard code the frame counter in the boilerplate loader code so that the entire loader function is loaded and decrypted into memory.  When the last frame of encrypted data is loaded and decrypted, the boilerplate code will jump to the loader function.

There is a caveat here.  I wouldn't do to much in your loader function other than load in your main executable and jump to it.  To do anything else like show a graphic and/or play music you will likely call library functions to do that.  Since the entire loader has to be encrypted, the library functions have to be included in the binary image that gets encrypted, thus duplicating the library function you use in the resulting binary.

My general strategy is to write a loader function that is the bare minimum needed to load in the main executable so that the encrypted loaded binary is as small and fast as possible.

==Thoughts on Lynx Loader Design==

If you want your main executable function for your game to be located at a specific location in RAM, such as in the zero page or at $0200, you will need to use a two-stage loader processes because of the encryption system and the way it works.

As described above, the Lynx ROM code is hard coded to decrypt the first block of data to $0200 and then jump to it.  If you want your game's main loop function to be located at $0200 you have two options:
# To designate your game's main function as the loader function using the #lynx.loader preprocessor directive.
# To use a two-stage loader so that the first stage gets you past the encryption and loads the second stage in zero page or way up in RAM and can then load your game's main function into to $0200 or your desired location before executing it.