=Function Declaration and Use=

==Declaring Functions==

HLAKit supports the declaration of functions to help organize your code into manageable chunks.  This is part of what makes it a high level assembler.  Below is the syntax for declaring functions:

====The Syntax====
{{{
#!c
type [noreturn] label([parameter0, parameter1, ... (inline only)])
{
    // body
}
}}}

===The Type of a Function===

HLAKit functions can be declared with one of three types: function, inline, or interrupt.  Functions declared with **//function//** are standard subroutines that end with a "return from subroutine" instruction (e.g. RTS on 6502).  Functions declared with "inline" are macros that are compiled inline with the calling code and do not contain a return instruction. Functions declared with "interrupt" are subroutines that end in a "return from interrupt handler" instruction (e.g. RTI on 6502).

===The "return" Keyword===

With normal subroutine and interrupt functions, the generation of the return from subroutine/interrupt opcodes are automatic.  However, HLAKit also supports the **return** keyword that can be used to exit a function early or to explicitly define the return from subroutine/interrupt opcode.  Including the **return**

===The "noreturn" Keyword===

With normal subroutine and interrupt functions the return from subroutine/interrupt instructions are automatic. Each function block is automatically terminated with the appropriate opcode.

The **noreturn** keyword will place the correct return opcode in your code depending on the function type. By using this keyword instead of the actual "RTS" and "RTI" opcodes, the code looks cleaner, and functions can easily be changed from standard to interrupt and vice vera without code modification. As well, macros can contain code which returns, and be used on both interrupts and standard functions.

The noreturn keyword disables the automatic "RTS" and "RTI" opcodes on functions. It can be used to save space when a function ends in a "JMP" or infinite loop, for example.

====Examples====
{{{
#!c
// A sample function using the return keyword
function SprOAM_FindFree()
{
    ldy #0
    lda [sprchk.addr], y // first byte is size
    tax
    do 
    {
        iny
        lda [sprchk.addr], y // each following byte is the oam index
        if(zero) 
        {
            return // returns REG.Y as the free index
        }
        dex
    } while(not zero)

    lda #1
}

// A start interrupt, since it ends with an infinite loop, there is no need for an RTS
interrupt.start noreturn main()
{
    // initialize game
    forever 
    {
        // do game  
    }
}
}}}


==Parameters==

Because NESHLA is an assembler and not a high level language such as C compiler, standard and interrupt functions can not use parameters. Parameters can only be used on inline (macro) functions.

NESHLA supports an unlimited amount of parameters, and they can be labeled anything using alphanumeric characters and underscores.

====Example====
{{{
#!c
inline assign(dest,value)
{
    lda value
    sta dest
}
}}}

==Interrupt Type Declaring==

Interrupt functions can optionally be declared with their subtype (start, nmi, irq). This does not automatically make them the function pointed to by the interrupt vector, but rather is used exclusively for error messages. If you define a interrupt as a certain type, then define it to a different interrupt vector, you will get an error. This is handy to prevent the accidental misuse of interrupts.

====Example====
{{{
#!c
// A start interrupt explicitly declared
interrupt.start main()
{
    // initialize game
    forever 
    {
        // do game  
    }
}

// an NMI interrupt with no subtype declaration
interrupt vblank()
{
    // do timing
}
}}}

==Calling Functions==

Functions can simply be called by their name as they are in high level languages. It will automatically use the correct jump opcode or insert the code (in the case of inline functions). Standard functions will have the "JSR" opcode for calling, while interrupts will be called with the "JMP" opcode. It addition, it will help prevent errors in your code, such as using a standard subroutine for an interrupt by mistake.

====Example====
{{{
#!c
// a sample macro
inline assign(dest,value)
{
    lda value
    sta dest
}

// normal function calling it
function testFunction()
{
    assign( someVar, #12 )
}
}}}