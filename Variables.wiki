[[[
===Variable Types===

HLAKit supports a fairly standard set of type names.  For complex data structures, there is a struct syntax for conglomerating basic types into structures.

It is important to note that the **dword** and the 32-bit **pointer** types are only present on CPU's that support them (e.g. 32-bit CPU's).  On 8/16-bit CPU's like the 6502, there is no **dword** and the **pointer** type is 16-bits.
]]]
[[[
===The Types===
|=Type|=Bytes|=Range|=Description|=Notes|
|byte|1|0 to 255|8 bit integer||
|char|1|-128 to +127|8 bit character||
|bool|1|zero or nonzero|8 bit boolean value (true/false)||
|word|2|0 to 65535|16 bit integer||
|dword|4|0 to 4294967295|32 bit integer|32 bit CPU's only|
|pointer|2/4|0x0000 to 0xFFFF 8/16 bit\\ 0x00000000 to 0xFFFFFFFF 32 bit|16/32 bit address pointer integer|32 bit pointers on 32-bit CPU's only|
|struct|-|-|A collection of variables and data||
]]]
[[[
===Defining Types===

The HLAKit language only supports defining new types using the ##typedef## and ##struct## keywords.  Both ##typedef## and ##struct## keywords work exactly like they do in the C language.
]]]
[[[
===The ##typedef## Keyword===

The ##typedef## keyword is used to define a new type alias.

====The Syntax====
{{{
#!c
// standard type alias
typedef type alias

// array type alias
typedef type alias[size]

// struct type alias
typedef struct label
{
    // struct members
} alias

// array of structs type alias
typedef struct label
{
    // struct members
} alias[size]
}}}

This is exactly like the way the C language creates alias with the ##typedef## keyword.  Note that the size in the array typedef expressions is optional.  However, if no size is given, all instances of the aliased type must have initializers so that the compiler can correctly calculate the size of each variable instance.

====Examples====
{{{
#!c
// standard type aliases
typedef byte INT
INT intVar  // this is a byte

typdef pointer LIST
LIST pInterestList // pointer variable

// array type alias
typedef byte buffer[32]
buffer myBuf // array of 32 bytes

// struct type alias
typedef struct player_
{
    byte x, y
    byte health
    byte experience
    pointer inventory
} player
player me // struct player variable
}}}

Normally, if you do not typedef a ##struct## type you have to declare variables using the full ##struct foo## type.  In the example above, the type ##struct player_## has been aliased as ##player## using ##typedef##.  From that point on, you can declare new variables using just ##player## instead of ##struct player_##.
]]]
[[[
===The ##struct## Keyword===

The ##struct## keyword is used to create new types that are structured containers of named members.  Structs can contain any number of members of any valid type, including other structs.

====The Syntax====
{{{
#!c
struct label
{
    type label[, label, ...]
}
}}}

Note that the type of the struct member can be any basic type or any already declared struct type.

====Examples====
{{{
#!c
// standard struct declare
struct time
{
    byte ticks
    byte seconds
    byte minutes
    byte hours
}

// struct declared with member list
struct scrollTo
{
    byte flags
    word x, y
}

// struct declared with member struct
struct player
{
    byte sprite
    byte joypad
    struct move
    {
        byte x, y
        byte amount
    } move
    byte anArray[10]
}

// a struct with two previously defined structs as members
struct scrollEvent
{
    struct scrollTo to
    struct time when
}
}}}

Struct members can be arrays but they must have a size specified.

When referencing struct members in your code you use dotted notation.

====Examples====
{{{
#!c
struct scrollEvent evt

// load the ticks into the X reg
ldx evt.when.ticks

struct player p

// store X reg into player array at index 2
stx p.anArray,2
}}}
]]]