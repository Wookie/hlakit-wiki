=Differences=

There are a few of subtle differences between the NESHLA language and the HLAKit language.  This page details those differences so that you can port your NESHLA code over to HLAKit.

==The ##sizeof## Keyword==

In NESHLA, there existed a ###sizeof## keyword that replaced itself with the size of the parameter.  In HLAKit the # has been dropped to make it a keyword like ##typedef##, ##struct##, and ##shared##.

====NESHLA====
{{{
#!c
cpy #sizeof(PALETTE)
}}}

is now:

====HLAKit====
{{{
#!c
cpy sizeof(PALETTE)
}}}

This makes HLAKit a little more like what C programmers are used to.

==The ##nylo## and ##nyhi## Keywords==

In NESHLA, the ##nylo## and ##nyhi## keywords returned the low nibble and high nibble respectively of a byte-sized variable or value.  These keywords are gone from HLAKit.  Instead, the ##lo## and ##hi## keywords work with all integral variables and values and return the low and high halves of their values respectively.

The keywords are stackable and can be used to select specific pieces of multibyte variables and values.  If you want to select the upper nibble of the lower byte in a word, you would just do the following:

====Example====
{{{
#!c
// load A with the upper nibble of the lower byte
lda hi(lo(a_word_var))
}}}

Also note that the # has been removed from the ##lo## and ##hi## keywords just like the ##sizeof## keyword.

====NESHLA====
{{{
#!c
lda #hi(0x1234) // loads A with 0x12
ldx #nylo(a_byte_var) // loads X with low nibble of byte
}}}

====HLAKit===
{{{
#!c
lda hi(0x1234) // loads A with 0x12
ldx lo(a_byte_var) // loads X with low nibble of byte
}}}
